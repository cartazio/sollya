
procedure nextDegree(n) {
        return n + 1;
};

procedure startDegree(n) {
        return n + 1;
};


procedure upperBoundPolyCoeffRests(l,I) {
        var bound;
        var myList;

        if (l == [||]) then {
                bound = [0];
        } else {
                myList = revert(l);
                bound = head(myList);
                myList = tail(myList);
                while (myList != [||]) do {
                        bound = bound * I + head(myList);
                        myList = tail(myList);
                };
        };

        return bound;
};


procedure myfindzerosAccurate(p,I,quality) {
        var nbZeros;
        var oldPoints;
        var fpZeros;
        var done;
        var z;
        var Z, Y;

        nbZeros = numberroots(p,I);

        oldPoints = points;
        points = nbZeros * 3!;
        done = false;
        while ((!done) && (points <= oldPoints)) do {
                fpZeros = dirtyfindzeros(p,I);
                if (length(fpZeros) == nbZeros) then {
                        done = true;
                } else {
                        points = points * 2!;
                };
        };
        points = oldPoints!;

        if (done) then {
                zeros = [||];
                for z in fpZeros do {
                        Z = [z - abs(quality * z); z + abs(quality * z)];
                        Y = evaluate(p,Z);
                        if (inf(Y) * sup(Y) <= 0) then {
                                zeros = zeros :. Z;
                        };
                };
                if (length(zeros) != nbZeros) then {
                        write("Warning: could not find enough high-quality zeros enclosures\n");
                        zeros = findzeros(p,I);
                };
        } else {
                write("Warning: could not find enough high-quality zeros enclosures\n");
                zeros = findzeros(p,I);
        };

        return zeros;
};

procedure myfindzerosQuick(p,I) {
        return findzeros(p,I);
};


procedure polyBoundQuick(p,I) {
        var pdiff;
        var z, zeros;
        var boundA, boundB, boundC, bound;
        var inner;

        pdiff = diff(p);
        
        boundA = evaluate(p,[inf(I)]);
        boundB = evaluate(p,[sup(I)]);  
        bound = boundA;
        inner = boundA;
        if (inf(boundB) < inf(bound)) then bound = [inf(boundB),sup(bound)];
        if (sup(boundB) > sup(bound)) then bound = [inf(bound),sup(boundB)];
        if (inf(boundB) > sup(inner)) then inner = [inf(inner),inf(boundB)];
        if (sup(boundB) < inf(inner)) then inner = [sup(boundB),sup(inner)];


        zeros = myfindzerosQuick(pdiff,I);

        for z in zeros do {
                boundC = evaluate(p,z);
                if (inf(boundC) < inf(bound)) then bound = [inf(boundC),sup(bound)];
                if (sup(boundC) > sup(bound)) then bound = [inf(bound),sup(boundC)];
                if (inf(boundC) > sup(inner)) then inner = [inf(inner),inf(boundC)];
                if (sup(boundC) < inf(inner)) then inner = [sup(boundC),sup(inner)];
        };

        return [| bound, inner |];
};

procedure polyBoundAccurate(p,I,quality) {
        var pdiff;
        var z, zeros;
        var boundA, boundB, boundC, bound;

        pdiff = diff(p);
        
        boundA = evaluate(p,[inf(I)]);
        boundB = evaluate(p,[sup(I)]);  
        bound = boundA;
        inner = boundA;
        if (inf(boundB) < inf(bound)) then bound = [inf(boundB),sup(bound)];
        if (sup(boundB) > sup(bound)) then bound = [inf(bound),sup(boundB)];


        zeros = myfindzerosAccurate(pdiff,I,quality);

        for z in zeros do {
                boundC = evaluate(p,z);
                if (inf(boundC) < inf(bound)) then bound = [inf(boundC),sup(bound)];
                if (sup(boundC) > sup(bound)) then bound = [inf(bound),sup(boundC)];
        };

        return bound;
};

procedure polyBound(p,I,quality) {
        var boundQuickRes;
        var boundQuickBound, boundQuickInner;
        var bound;

        boundQuickRes = polyBoundQuick(p,I);
        boundQuickBound = boundQuickRes[0];
        boundQuickInner = boundQuickRes[1];
        
        if ((abs(inf(boundQuickInner) - inf(boundQuickBound)) <= abs(quality * inf(boundQuickInner))) && 
            (abs(sup(boundQuickBound) - sup(boundQuickInner)) <= abs(quality * sup(boundQuickInner)))) then {
                bound = boundQuickBound;
        } else {
                bound = polyBoundAccurate(p,I,quality);
        };

        return bound;
};


procedure recurseFindZeros(p,I,n) {
        var res;
        var zeros;
        var z;

        if (n < 1) then {
                res = findzeros(p,I);
        } else {
                zeros = recurseFindZeros(p,I,n-1);
                res = [||];
                for z in zeros do {
                        res = res @ findzeros(p,z);
                };
        };

        return res;
};

procedure showPositivity(p,I,silent) {
        var res;
        var zeros;
        
        res = (numberroots(p,I) == 0);

        if (!res) then {
                zeros = recurseFindZeros(p,I,2);
                res = (zeros == [||]);
        };

        if ((!res) && (!silent)) then {
                write("Warning: could not show positivity\n");
                write("Warning: the function might have zeros in ",zeros,"\n");
        };

        return res;
};

procedure checkPolyBound(p,I,bound,silent) {
        var res;
        var qUp, qDown;
        var sosInstances;

        qUp = -(p - sup(bound));
        qDown = p - inf(bound);

        res = (showPositivity(qUp,I,silent) && showPositivity(qDown,I,silent));
        
        sosInstances = [| [| qUp, I |], [| qDown, I |] |];

        return [| res, sosInstances |];
};


procedure polyApprox(f,I,x0,n,mode) {
        var p;
        var Delta, DeltaCoeffs, DeltaLagrange;
        var TM;
        var oldRationalMode, oldRoundingWarnings;
        var T, TRounded, TDiff;
        var DeltaRound;

        TM = taylorform(f,n,x0,I,mode);
        p = TM[0];
        if (mode == absolute) then {
                DeltaLagrange = TM[2];
        } else {
                DeltaLagrange = evaluate(x^(n-1),I-x0) * TM[2];
        };
        DeltaCoeffs = upperBoundPolyCoeffRests(TM[1],I-x0);
        oldRationalMode = rationalmode;
        rationalmode = on!;
        T = horner(simplifysafe(p(x - x0)));
        rationalmode = oldRationalMode!;
        TRounded = roundcoefficients(T,[| prec... |]);
        TDiff = horner(T - TRounded);
        DeltaRound = evaluate(TDiff,I);
        Delta = DeltaCoeffs + DeltaLagrange + DeltaRound;
        return [| TRounded, Delta |];
};

procedure supnormLowBound(p,f,I,quality,mode) {
        var res;
        var zeros;
        var g, gPrime;
        var z, b;

        if (mode == absolute) then {
                g = p - f;
        } else {
                g = p/f-1;
        };

        res = dirtyinfnorm(g,I);

        res = round(res,floor(-log2(abs(quality))),RD);

        return res;
};


procedure supnormAbsolute(p,f,I,quality) {
        var n;
        var x0;
        var TDelta;
        var T, Delta;
        var DeltaDiff;
        var r, res;
        var lowBound;
        var done;
        var q;
        var oldMidpointMode;
        var sosInstances;
        var polyBoundRes;
        var highBound;
        var rWidening, DeltaDiffWidened, rWidened, highBoundWidened;

        x0 := mid(I);
        n = startDegree(degree(p));

        lowBound = supnormLowBound(p,f,I,quality/4,absolute);
        highBound = infty;

        done = false;
        while ((n < 200) && (!done)) do {        
                TDelta = polyApprox(f,I,x0,n,absolute);
                T = TDelta[0];
                Delta = TDelta[1];
                q = p-T;

                DeltaDiff = polyBound(q,I,quality/4);

                r = -Delta + DeltaDiff;

                highBound = abs(sup(r));
                if (abs(inf(r)) > highBound) then {
                    highBound = abs(inf(r));    
                };
                
                if (highBound - lowBound < 0) then {
                        write("Warning: highBound is less than lowBound.\n");
                        write("highBound = ",highBound,"\n");
                        write("lowBound  = ",lowBound,"\n");
                };

                if (abs(highBound - lowBound) < abs(lowBound * quality)) then {
                        done = true;
                } else {
                        oldMidpointMode = midpointmode;
                        midpointmode = on!;
                        write("Information: n = ",n,": current bounding ",[lowBound,highBound],"\n");
                        midpointmode = oldMidpointMode!;
                        n = nextDegree(n);
                };
        };

        if (done) then {
                DeltaDiffWidened = [-(lowBound * (1 + abs(quality/4))) + sup(Delta);(lowBound * (1 + abs(quality/4))) + inf(Delta)];
                rWidened = DeltaDiffWidened - Delta;
                highBoundWidened = abs(sup(rWidened));
                if (abs(inf(rWidened)) > highBoundWidened) then {
                    highBoundWidened = abs(inf(rWidened));    
                };
                if ((highBoundWidened - lowBound >= 0) && (abs(highBoundWidened - lowBound) < abs(lowBound * quality))) then {
                        polyBoundRes = checkPolyBound(q,I,DeltaDiffWidened,true);
                        if (polyBoundRes[0]) then {
                                sosInstances = polyBoundRes[1];
                                res = [lowBound,highBoundWidened];
                        } else {
                                write("Information: widening did not work, check direct evaluation\n");
                                polyBoundRes = checkPolyBound(q,I,DeltaDiff,false);
                                if (polyBoundRes[0]) then {
                                        sosInstances = polyBoundRes[1];
                                        res = [lowBound,highBound];
                                } else {
                                        write("Warning in supnorm: could not check polynomial bounds.\n");
                                        res = [lowBound;sup(abs(evaluate(p-f,I)))];
                                        sosInstances = [||];
                                };
                        };
                } else {
                        polyBoundRes = checkPolyBound(q,I,DeltaDiff,false);
                        if (polyBoundRes[0]) then {
                                sosInstances = polyBoundRes[1];
                                res = [lowBound,highBound];
                        } else {
                                write("Warning in supnorm: could not check polynomial bounds.\n");
                                res = [lowBound;sup(abs(evaluate(p-f,I)))];
                                sosInstances = [||];
                        };
                };
        } else {
                write("Warning in supnorm: could not achieve the desired quality.\n");
                res = [lowBound;sup(abs(evaluate(p-f,I)))];
        };

        return [| res, sosInstances |];
};

procedure encloseZeros(f,I) {
        var res;
        var oldDiam;

        oldDiam = diam;
        diam = 1/16!;
        res = findzeros(f,I);
        diam = oldDiam!;
        return res;
};

procedure globIntervals(l) {
        var res;
        var myL;
        var curr, rescurr;

        if (length(l) <= 1) then {
                res = l;
        } else {
                myL = l;
                rescurr = head(myL);
                myL = tail(myL);
                res = [||];
                while (myL != [||]) do {
                        curr = head(myL);
                        myL = tail(myL);
                        if (inf(curr) > sup(rescurr)) then {
                                res = rescurr .: res;
                                rescurr = curr;
                        } else {
                                rescurr = [inf(rescurr);sup(curr)];
                        };
                };
                res = rescurr .: res;

                res = revert(res);
        };

        return res;
};

procedure invertIntervals(l,I) {
        var res;
        var myL;
        var curr;
        var a, b, bmax;

        if (l == [||]) then {
                res = [| I |];
        } else {
                myL = l;
                curr = head(myL);
                myL = tail(myL);
                bmax = sup(I);
                if (inf(curr) > inf(I)) then {
                        a = inf(I);
                        b = inf(curr);
                        if (bmax < b) then b = bmax;
                        res = [| [a;b] |];
                } else {
                        res = [||];
                };
                a = sup(curr);
                while ((myL != [||]) && (a < bmax)) do {
                        curr = head(myL);
                        myL = tail(myL);
                        b = inf(curr);
                        if (bmax < b) then { 
                                b = bmax;
                                myL = [||];
                        };
                        res = [a;b] .: res;
                        a = sup(curr);
                };
                if (a < bmax) then {
                        res = [a;bmax] .: res;
                };
                res = revert(res);
        };

        return res;
};


procedure supnormRelativeNoPole(p,f,I,quality,x0,taylorModelMode) {
        var n;
        var TDelta;
        var T, Delta;
        var res;
        var highBound, lowBound;
        var done;
        var r;
        var alpha, DeltaRel, DeltaDiffRel;
        var oldDisplay;
        var h;
        var oldRationalMode;
        var oldMidpointMode;
        var sosInstances;
        var R, Eta;

        n = startDegree(degree(p));

        lowBound = supnormLowBound(p,f,I,quality/4,relative);
        highBound = infty;

        done = false;
        while ((n < 200) && (!done)) do {        
                TDelta = polyApprox(f,I,x0,n,taylorModelMode);
                T = TDelta[0];
                Delta = TDelta[1];

                alpha = polyBound(T,I,quality/4);
                DeltaRel = -Delta / (alpha + Delta);
                
                R = [- (lowBound * (1 + quality/2)); (lowBound * (1 + quality/2)) ];
                Eta = (R - DeltaRel) / (1 + DeltaRel);

                eta = abs(sup(Eta));
                if (abs(inf(Eta)) > eta) then eta = abs(inf(Eta));

                qUp = horner(-(p - T * (1 + eta)));
                qDown = horner(p - T * (1 - eta));

                DeltaDiffRel = [-eta;eta];

                r = DeltaDiffRel + DeltaRel + DeltaDiffRel * DeltaRel;

                highBound = abs(sup(r));
                if (abs(inf(r)) > highBound) then {
                    highBound = abs(inf(r));    
                };

                if (abs(highBound - lowBound) < abs(lowBound * quality)) then {
                        positiveUp = showPositivity(qUp,I,false);
                        positiveDown = showPositivity(qDown,I,false);
                } else {
                        positiveUp = false;
                        positiveDown = false;
                };
                
                if (positiveUp && positiveDown) then {
                        done = true;
                } else {
                        oldMidpointMode = midpointmode;
                        midpointmode = on!;
                        write("Information: n = ",n,": current bounding ",[lowBound,highBound],"\n");
                        midpointmode = oldMidpointMode!;
                        n = nextDegree(n);
                };
        };

        if (done) then {
                res = [lowBound,highBound];
                sosInstances = [| [| qUp, I |], [| qDown, I |] |];
        } else {
                write("Warning in supnorm: could not achieve the desired quality\n");
                res = [lowBound;highBound];
        };

        return [| res , sosInstances |];
};

procedure determineOrderOfZero(f,x0,n) {
        var k;
        var TM;
        var T; 
        var coeffBounds;
        
        TM = taylorform(f,n,x0,relative);
        T = TM[0];
        coeffBounds = TM[1];
        k = 0;
        while ((coeff(T,k) == 0) && (coeffBounds[k] == [0])) do {
                k = k + 1;
        };
        
        return k;
};

procedure findpoles(p,f,I) {
        var res;

        if ((inf(I) * sup(I) < 0) && (p(0) == 0)) then {
                res = [|0|];
        } else {
                res = dirtyfindzeros(f,I);
                if (res == [||]) then {
                        res = dirtyfindzeros(p,I);
                };
        };

        return res;
};

procedure supnormRelativePole(p,f,I,quality) {
        var poles;
        var res;
        var x0;
        var k, pTilde, fTilde, oldDisplay;
        
        poles = findpoles(p,f,I);
        if (poles == [||]) then {
                write("Warning in supnorm: did not find false pole\n");
                res = supnormRelativeNoPole(p,f,I,quality,mid(I),absolute);
        } else {
                x0 = round(head(poles),floor(prec/2),RN);
                k = determineOrderOfZero(f,x0,degree(p));
                if (k == k) then {
                        pTilde = horner((horner(p(x + x0))/(x^k))(x - x0));
                        if (degree(pTilde) == degree(p) - k) then {
                                fTilde = f/((x - x0)^k);
                                res = supnormRelativeNoPole(pTilde,fTilde,I,quality,x0,relative);
                        } else {
                                write("Warning in supnorm: determined pole seems not to be a false one\n");
                                res = [| [0;infty], [||] |];
                        };
                } else {
                        write("Warning in supnorm: could not determine order of pole\n");
                        res = [| [0;infty], [||] |];
                };
        };

        return res;
};

procedure supnormRelative(p,f,I,quality) {
        var possiblePoles;
        var noPoles;
        var i;
        var resCurr;
        var innerBound, outerBound;
        var resCurrNorm;
        var sosInstances;

        possiblePoles = globIntervals(encloseZeros(f,I));
        noPoles = invertIntervals(possiblePoles,I);

        write("Information: splitting the domain into subdomains ",possiblePoles," (with possible poles) and ",noPoles," (without poles)\n");

        innerBound = 0;
        outerBound = 0;
        sosInstances = [||];
        for i in possiblePoles do {
                write("Information: doing subdomain ",i,"\n");
                resCurr = supnormRelativePole(p,f,i,quality);
                resCurrNorm = resCurr[0];
                sosInstances = resCurr[1] @ sosInstances;
                if (inf(resCurrNorm) > innerBound) then innerBound = inf(resCurrNorm);
                if (sup(resCurrNorm) > outerBound) then outerBound = sup(resCurrNorm);
        };
        for i in noPoles do {
                write("Information: doing subdomain ",i,"\n");
                resCurr = supnormRelativeNoPole(p,f,i,quality,mid(i),absolute);
                resCurrNorm = resCurr[0];
                sosInstances = resCurr[1] @ sosInstances;
                if (inf(resCurrNorm) > innerBound) then innerBound = inf(resCurrNorm);
                if (sup(resCurrNorm) > outerBound) then outerBound = sup(resCurrNorm);
        };

        return [| [innerBound, outerBound], sosInstances |];
};


procedure supnorm(p,f,I,quality,mode) {
        var res;

        res = error;
        if (mode == absolute) then {
                res = supnormAbsolute(p,f,I,quality);
        } else {
                if (mode == relative) then {
                        res = supnormRelative(p,f,I,quality);
                };
        };

        return res;
};

