restart;
print("=============== Test number 1 ================");
/* Non-regression test for a segfault bug in fpminimax, fixed on November 20th 2015 */
fpminimax(exp(x),5,[|D,D,D,D,D|],[-1;1]);

restart;
print("=============== Test number 2 ================");
/* Non-regression test for bug #16632 */
/* The following example should not fall into an infinite loop */
f = 2473 - 4979*x/10 + 3971*x^2/100 - 157*x^3/100 + 77*x^4/2500 - 3*x^5/12500;
points=4!;
a=dirtyfindzeros(f, [10, 50]);
length(a)==3;

restart;
print("=============== Test number 3 ================");
/* Non-regression test for bug #11966 */
/* The following example should not fall into an infinite loop */
points=4; dirtyfindzeros( (x-(2-1b-300))*(x-(2+1b-300)), [1,5]);

restart;
print("=============== Test number 4 ================");
/* Non-regression test for bug patched with commit bc748a402983af1c2b72e7faabc5c3344e2013cf */
p = implementpoly(5933108082745413b-47 + x * (8371870699358531b-57 + x * (-5019189491068933b-64 + x * (-1235985524236843b-65 + x * (5928085562303317b-76 + x * (7007054019943729b-80 + x * (-1400231163274209b-87 + x * (-2363983593233507b-92))))))),[-2961770179049179b-51;740442544762295b-49],3b-54,double,"f","implementation.c",honorcoeffprec);
bashevaluate("tail -n 44 implementation.c");

restart;
print("=============== Test number 5 ================");
/* Non regression test for bug [#20056] Division by zero when computing a degree */
p = ((1 + x)^3000); degree(diff(p));


restart;
print("=============== Test number 6 ================");
/* Non regression test for bug [#19925] Convention used for hexadecimal display */
display=hexadecimal;
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
10;
11;
12;
13;
14;
15;
16;
33;
33 ==  0x84p-2;
33 ==  0x42p-1;
33 ==  0x21p0;
33 == 0x108p-3;
9993249 * 2^(-2);
9993249 * 2^(-2) == 0x2.61f084p20;
9993249 * 2^(-2) == 0x9.87c21p18;
0x7.abba18p-4;
0x7.abba2p-4;
-0xa.88bd7p-8;
-0xa.88bc8p-8;
0xb.69013p-12;
-0x4.0fcb5p-8;
0xa.df75ap-8;
-0x1.33194ep-4;
0x1.b403a8p-4;
-0x2.45eb84p-4;
0x3.32ee9p-4;
-0x5.55536p-4;
-0x1.5554d8p0;
-0x1.5554d8p20;
-0xa.aaa6cp16;

restart;
print("=============== Test number 7 ================");
/* Non regression test for bug [#7085] Rounding to simple value with infinity overflow is wrong */
procedure insertIntoSet(S, e) {
	  var res;
	  var T, i, contained;

	  contained = false;
	  T = S;
	  while ((!contained) && (T != [||])) do {
	  	i = head(T);
		T = tail(T);
		if (i == e) then {
		   contained = true;
		};
	  };

	  if (contained) then {
	     res = S;
	  } else {
	     res = e .: S;
	  };
	  
	  return res;
};


procedure ulpSingle(X) {
	  var absX, res;
	  
	  absX = abs(X);
	  if (absX < 0x00800000) then {
	     res = 1b-149;
	  } else {
	     res = 2^(floor(log2(absX)) - 24 + 1);
	  };

	  return res;
};

procedure ulpDouble(X) {
	  var absX, res;
	  
	  absX = abs(X);
	  if (absX < 0x0010000000000000) then {
	     res = 1b-1074;
	  } else {
	     res = 2^(floor(log2(absX)) - 53 + 1);
	  };

	  return res;
};

procedure ulpNatif(X) {
	  return 2^(floor(log2(abs(X))) - 165 + 1);
};

procedure testsingle(X) {
	  var res, absX, sgnX, E;

	  if (X >= 340282356779733661637539395458142568448) then {
	     res = infty;
	  } else {
	     if (X <= -340282356779733661637539395458142568448) then {
	     	res = -infty;
	     } else {
	       if (X < 0) then {
	       	  absX = -X;
		  sgnX = -1;
	       } else {
	       	  absX = X;
		  sgnX = 1;
	       };
	       if (absX <= 1b-150) then {
	       	  res = 0;
	       } else {
	       	  E = floor(log2(absX));
		  if (E <= -126) then {
		     E = -126;
		  };
		  ulp = 2^(E - 24 + 1);
		  res = ulp * nearestint(absX / ulp);
	       };
	       res = sgnX * res;
	     };
	  };

	  return res;
};

write("Computing data to test rounding to single precision\n");
prec = 2000!;
fudges = [| 1b-1800, 1b-1076, 1b-1075 |];
testvalues = [||];
for s in [| 1b-149, 0x007fffff, 0x7f7fffff |] do {
    u = ulpSingle(s);
    for t in [| s, s - 1/2 * u, s - 1/4 * u, s - 1/8 * u, s + 1/4 * u, s + 1/2 * u |] do {
    	uu = ulpDouble(t);
	for r in [| t, t - 1/2 * uu, t - 1/4 * uu, t - 1/8 * uu, t + 1/4 * uu, t + 1/2 * uu |] do {
	    uuu = ulpNatif(r);
	    for z in [| r, r - 1/2 * uuu, r - 1/4 * uuu, r - 1/8 * uuu, r + 1/4 * uuu, r + 1/2 * uuu |] do {
	    	for f in fudges do {
		    for v in [| z, -z, z - f, z + f, -z + f, -z - f |] do {
		    	testvalues = v .: testvalues;	
		    };
		};
	    };
	};
    };
};

prec = 165!;
roundingwarnings=on!;
display = hexadecimal!;

write("Starting actual test\n");
resvalues = [||];
okay = true;
for v in testvalues do {
    sv = round(v, SG, RN);
    tv = testsingle(v);
    if (sv != tv) then {
       write("Wrong rounding to single precision detected for v = ", v, ", expected ", tv, ", got ", sv, " = "); printsingle(sv);
       okay = false;
    };
    resvalues = insertIntoSet(resvalues, sv);
};

if (okay) then {
   write("All test values for rounding to single precision have yielded a correct result.\n");
};

write("Now testing printsingle displaying\n");
for v in resvalues do {
    write(v, " = "); printsingle(v);
};

write("End of test\n");

restart;
print("=============== Test number 8 ================");
/* Non regression test for bug [#17196] Inconsistent behavior of evaluate */
evaluate(x * (2/sin(x)), 0) == evaluate(x * 2/sin(x), 0);

restart;
print("=============== Test number 9 ================");
/* Non regression test for bug [#14451] guessdegree has a strange behavior on point intervals */
guessdegree(1,[0.3125e-1;0.3125e-1],1b-20,1 / exp(x));

restart;
print("=============== Test number 10 ================");
/* Non regression test for bug [#20070] getbacktrace does not conform to its documentation */
procedure test(l=...) { getbacktrace(); };
test @ [|1, "Coucou", 3...|];

restart;
print("=============== Test number 10b ================");
/* Elementary test for getbacktrace */
procedure testA() { "Current backtrace:"; getbacktrace(); };
procedure testB(X) {"X = ", X; testA(); };
procedure testC(X, Y) {"X = ", X, ", Y = ", Y; testB(Y); };
testC(17, 42);

restart;
print("=============== Test number 10c ================");
/* getbacktrace at top level returns an empty list */
getbacktrace();

restart;
print("=============== Test number 10d ================");
/* getbacktrace togther with objectname. Example of a procedure accepting a list as argument, and of a procedure with an arbitrary number of arguments */
procedure printnumargs(X) {
  var L, t;
  "number of arguments: ", X;
  L = getbacktrace();
  "Backtrace:";
  for t in L do {
    "  " @ objectname(t.called_proc) @ ", ", t.passed_args;
  };
};
procedure numargs(l = ...) {
  if (length(l)>17) then "l[17] = ", l[17];
  printnumargs(length(l));
};
procedure test1() { numargs @ [|25, 26, 27 ...|]; };
procedure test2(x) { numargs @ x; };
test1();
test2([|1,2,3|]);

restart;
print("=============== Test number 11 ================");
/* Non regression test for bug [#20071] Using annotatefunction leads to a unexpected approximation warning. */
verbosity = 1!;
roundingwarnings = on!;
prec = 80!;
procedure EXP(X,n,p) {
var res, oldPrec;
oldPrec = prec;
prec = p!;

"Using procedure function exponential with X = ", X, ", n = ", n, ", p = ", p;

res = exp(X);

prec = oldPrec!;
return res;
};
g = function(EXP);
p = 46768052394588893382516870161332864698044514954899b-165 + x * (23384026197294446691258465802074096632225783601255b-164 + x * (5846006549323611672948426613035653821819225877423b-163 + x * (3897337699549074448627696490806815137319821946501b-164 + x * (7794675399098148717422744621371434831048848817417b-167 + x * (24942961277114075921122941174178849425809856036737b-171 + x * (8314320425704876115613838900105097456456371179471b-172 + x * (19004160973039701371579356991645932289422670402995b-176 + x * (19004160972669324148912122254449912156003926801563b-179 + x * (33785175062542597526738679493857229456702396042255b-183 + x * (6757035113643674378393625988264926886191860669891b-184 + x * (9828414707511252769908089206114262766633532289937b-188 + x * (26208861108003813314724515233584738706961162212965b-193 + x * (32257064253325954315953742396999456577223350602741b-197 + x * (578429089657689569703509185903214676926704485495b-195 + x * 2467888542176675658523627105540996778984959471957b-201))))))))))))));
g= annotatefunction(g, p, [-1/2;1/2], [-475294848522543b-124;475294848522543b-124]);
g(0.25);
prec=53!;
g(1/3);
g(0.25);
prec=80!;
g(1/3);

restart;
print("=============== Test number 12 ================");
/* Non regression test for bug [#20094] NaN comparisons do not work as expected. */
NaN == NaN;
NaN != NaN;
b = NaN;
b == b;
b != b;
error == error;
error != error;
a = error;
a == a;
a != a;
a == @NaN@;
a != @NaN@;
b == error;
b != error;
a == b;
a != b;
match a with @NaN@: ("Is a NaN") default: ("Is not a NaN");
match error with @NaN@: ("Is a NaN") default: ("Is not a NaN");
match b with @NaN@: ("Is a NaN") default: ("Is not a NaN");
match @NaN@ with @NaN@: ("Is a NaN") default: ("Is not a NaN");
match [||] with @NaN@: ("Is a NaN") default: ("Is not a NaN");

restart;
print("=============== Test number 13 ================");
filename = "tmpFile-check029" @ __unique_id @ ".sollya";
count = 0;
print("procedure contains(elem, L) {") > filename;
print("  var t, res;") >> filename;
print("  res = false;") >> filename;
print("  for t in L do {") >> filename;
print("    if elem == t then res = true;") >> filename;
print("  };") >> filename;
print("  return res;") >> filename;
print("};\n") >> filename;
for a1 in [|true,false|] do { for a2 in [|true,false|] do { for a3 in [|true,false|] do {
  for b1 in [|true,false|] do { for b2 in [|true,false|] do { for b3 in [|true,false|] do {
    for c1 in [|true,false|] do { for c2 in [|true,false|] do { for c3 in [|true,false|] do {
      count = count + 1;
      if a1 then print("a" @ count @ " = exp(x) + " @ count @ ";") >> filename;
      if b1 then print("b" @ count @ " = cos(x);") >> filename;
      if c1 then print("c" @ count @ " = cos(x);") >> filename;
      print("procedure test() {") >> filename;
      if a2 then print("  var a" @ count @ ";") >> filename;
      if b2 then print("  var b" @ count @ ";") >> filename;
      if c2 then print("  var c" @ count @ ";") >> filename;
      if a2 then print("  a" @ count @ " = cos(x);") >> filename;
      if b2 then print("  b" @ count @ " = exp(x) + " @ count @ ";") >> filename;
      if c2 then print("  c" @ count @ " = cos(x);") >> filename;
      print("  procedure test_inner() {") >> filename;
      print("    var s, expected;") >> filename;
      if a3 then print("    var a" @ count @ ";") >> filename;
      if b3 then print("    var b" @ count @ ";") >> filename;
      if c3 then print("    var c" @ count @ ";") >> filename;
      if a3 then print("    a" @ count @ " = cos(x);") >> filename;
      if b3 then print("    b" @ count @ " = cos(x);") >> filename;
      if c3 then print("    c" @ count @ " = exp(x) + " @ count @ ";") >> filename;

      expected = [||];
      if c3 then expected = expected :. ("c" @ count);
      if (b2 && (!b3)) then expected = expected :. ("b" @ count);
      if (a1 && (!a2) && (!a3)) then expected = expected :. ("a" @ count);
      display = hexadecimal!;
      if expected == [||] then expected = [|"(exp(x)) + (" @ count @ ")"|];
      print("    s = objectname(exp(x) + " @ count @ ");") >> filename;
      display = decimal!;

      print("    expected = " @ expected @ ";") >> filename;
      print("    if (exp(x) + " @ count @ " != parse(s)) then print(\"Error detected [|a1,a2,a3,b1,b2,b3,c1,c2,c3|] = \", " @ [|a1,a2,a3,b1,b2,b3,c1,c2,c3|] @ ");") >> filename;
      print("    if !contains(s, expected) then print(\"Unexpected \",s,\"(should belong to \", expected, \"). [|a1,a2,a3,b1,b2,b3,c1,c2,c3|] = \", " @ [|a1,a2,a3,b1,b2,b3,c1,c2,c3|] @ ");") >> filename;
      print("    return void;") >> filename;
      print("  };") >> filename;
      print("  test_inner();") >> filename;
      print("  return void;") >> filename;
      print("};") >> filename;
      print("test();\n") >> filename;
    };};};
  };};};
};};};

print("Running systematic tests for objectname...");
execute(filename);
print("Test run. Removing temporary file.");
bashexecute("rm -rf " @ filename);
print("End of tests for objectname.");

restart;
print("=============== Test number 14 ================");
/* Non-regression test for bug fixed on 2016, July 27th */
/* The following example should not fall into an infinite loop */
prec = 350!;
verbosity=0!;
zero = 1b-100;
dom = [zero;0x3fefffffffffffff];
q = x * (2918320636831873b-51 + x^2 * (-2812036178508593b-51 + x^2 * 3308766278594951b-51));
s = x * (9007199254740653b-53 + x^2 * (-3002399751552901b-54 + x^2 * (1200959899164001b-57 + x^2 * (-7320135585671187b-65 + x^2 * (1626678530493517b-69 + x^2 * (-7565607198486585b-78 + x^2 * 5975262180392203b-85))))));
c = 9007199254729395b-53 + x^2 * (-9007199253965425b-54 + x^2 * (3002399733779339b-56 + x^2 * (-6405116931749881b-62 + x^2 * (7319959653218259b-68 + x^2 * (-5198970630914559b-74 + x^2 * 4809296948379375b-81)))));
t = s(q);
h = c(q);
r = x * h - t * sqrt(1 - x^2);
p= remez(1-q/asin(x), [|r/asin(x), r^3/asin(x)|], dom, 1, 1e-2);
print("Succeeded.");

restart;
print("=============== Test number 15 ================");
/* Non-regression test for bug #8867 */
/* The following examples should not fall into an infinite loop */
verbosity = 0!;
b=round(pi,53,RD); p=remez(1,[|1,...,6|],[-1,b],1/sin(x));
print("Loop was not infinite");

restart;
print("=============== Test number 15bis ================");
/* Non-regression test for bug #8867 */
/* The following examples should not fall into an infinite loop */
verbosity = 0!;
prec=250;
L = [|(x * 6215193255146273b-52 * sqrt(1 - x^2)) / x, (x^3 * 240084383221639362889634237063322305672153048417b-156 * sqrt(1 - x^2)) / x, (x^5 * 9274130135726315977204924027295787401259172547694862836311277722826903837042593b-260 * sqrt(1 - x^2)) / x, (x^7 * 358246915606274140191920304152769949749350577336553141294816968955983915567186730677646875115691472828069001697b-364 * sqrt(1 - x^2)) / x, (x^9 * 13838586548080362858940014402840360268995306239673696598277155473497177385003491303000131757744686625519952014193459235397229970270226467527713b-468 * sqrt(1 - x^2)) / x, 1, x^2 * 38628627198815724950998625790529b-104, x^4 * 1492170839265086001261130874140987270862577211466609670186099841b-208, x^6 * 57640511066914988424865872984169909598464624435858660244460993055001291786871802866265946205889b-312, x^8 * 2226573813553071122888224017176137039898190767752187705723358029551392386421767103114971542147284427945827772826758090820225281b-416|];
f = cos(x * 6215193255146273b-52) - sin(x * 6215193255146273b-52) * sqrt(1 - x^2)/x;
p = remez(f,L,[1b-100;9007199254740991b-53]);
print("Loop was not infinite");

